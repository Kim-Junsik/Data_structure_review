## 리스트
리스트는 배열과 달리 원소들 간의 논리적인 순서를 위한 자료구조로 물리적인 위치는 고려하지 않음. 그래서 리스트와 배열을 비교하여 알아두면 좋음.

### 리스트와 배열의 비교

    - 배열의 순서는 물리적이라고 말할 수 있으며 리스트의 순서는 논리적(추상적, 의미적)이라고 말할 수 있음.
    - 배열을 이용하여 리스트를 구현하면 논리적인 순서를 지키기 위해 불필요한 원소의 이동이 많아짐.
    - 따라서 불필요한 이동을 포인터 변수와 동적 메모리 할당을 이용하여 해결이 가능함.

따라서 배열, 포인터를 이용하여 리스트의 구현이 가능함.

#### 배열을 이용한 리스트의 구현
###### 소개하기 이전 앞에서도 언급했던 자료의 삽입 삭제가 빈번히 발생하는 상황에서는 컴퓨팅 성능의 비효율을 유발함.

<p align="center"><img src="https://user-images.githubusercontent.com/45933225/84011375-f819cc80-a9b0-11ea-90d3-654bbe058050.png" width="60%"></p>

배열을 이용하여 리스트를 구현하는 방법은 간단하게 말하자면 리스트의 원소를 순서대로 배열에 저장하는 것이라고 말할 수 있음. 장점으로는 포인터를 위한 메모리가 필요 없기 때문에 메모리 공간 활용 효율이 높다는 것과 단점으로는 배열의 특성으로 각 원소가 메모리에 순차적으로 저장되는 것에 해당함. 따라서 삽입, 삭제와 같은 변동 많을 경우 많은 시간이 걸림.

따라서 IT서비스 환경에서 배열을 이용한 리스트의 구현은 잘 사용되지 않음. 그래도 필요한 환경에 맞춰서 사용하기 위하여 각 장단점을 파악할 필요가 있음.

#### 포인터를 이용한 리스트의 구현
간단하게 말하자면, 포인터를 이용해 구현된 리스트를 연결 리스트(linked lsit)라고 함.

<p align="center"><img src="https://user-images.githubusercontent.com/45933225/84010274-69f11680-a9af-11ea-9c98-216ec8974f88.png" width="60%"></p>

위에서 각 블록은 노드(node)라는 개념으로 사용되며 이는 데이터를 갖고 있는 데이터 필드와 다음 노드의 주소를 갖고 있는 링크 필드(포인터)로 구성됨.

따라서 이것을 추상화한 연결 리스트의 표현이라고 하며 각 원소가 저장된 메모리의 물리적인 주소는 순서에 상관없이 저장됨.

보통 C언어에서는 struct 데이터 타입으로 구현되며 안에는 여러 종류의 값이나 정보가 저장될 수 있으며 링크 필드도 안에 포인터 변수를 이용하여 구현이 가능함.

그리고 위 그림을 보면 head 포인터 변수는 연결 리스트의 시작 노드(첫 번째 원소)를 가리키며 마지막 노드는 링크 필드로 null 포인터로 표현함.

연결리스트의 구성으로 미리 간단하게 말하자면 또 더미 노드가 있고 없는 것으로 나눠서 구현을 함.

#### 포인터 변수, 구조체, 동적 메모리 할당을 통한 구현

    -   struct node
    -   node* create_node(int data)
    -   void append_node(node **head, *newnode)
    -   void insert_after(node *ptr, node *newnode)
    -   void delete_node(node *head)
    -   node * get_node(node *head, int index)
    -   print_list(node *head)

##### struct node 구조체
각 노드에 필요한 데이터 타입을 저장하기 위한 자료 구조체로 기본적으로 데이터를 저장하기 위한 int형 변수와 다음 노드를 연결하기 위한 자기 참조 포인터 변수를 가지고 있음.

    - int data;
    - struct node * next;

##### create_node 함수
노드 구조체를 메모리 동적 할당하여 필요한 메모리 확보한 다음 필요한 데이터를 삽입하고 포인터 연결 주소는 NULL로 지정하여 반환해줌.

##### append_node 함수
head의 정보를 임시 할당을 받은 노드가 받아서 이어서 처리하는 방법으로 NULL을 가지고 있다면 그 자리에 노드를 추가해주거나 그게 아니라면 연결시켜주는 next 포인터 변수가 NULL을 가지고 있을 때까지 이동하여 그 자리에 노드를 삽입해줌.

##### insert_after 함수
기존에 지정하고 있는 노드에 포인터변수를 새로운 노드에 대입하며 기존 노드에 새로운 노드를 가리키게 함으로써 중간에 공백 없이 계속해서 연결 노드를 이어갈 수 있게 함.

##### delete_node 함수
head의 정보를 임시 할당을 받은 노드가 받고 노드 삭제를 위한 임시 할당을 받은 노드를 하나 더 생성함으로써 head의 정보를 가지고 있는 포인터 변수가 NULL을 가지고 있을 때까지 이동하여 다른 임시 할당을 받은 노드가 head 정보를 이어받음으로써 처음으로 head의 정보를 받은 노드를 NULL로 지정 후 마지막 노드를 가리키는 것을 동적 할당을 해제해줌.

##### get_node 함수
index를 직접적으로 참조하지는 않지만 매개변수로 index를 받음으로써 기존의 포인터 변수 횟수를 지정해줄 수 있다(한번 이동할 때마다 index의 정수를 차감함으로써 index가 0 이상일 때까지 이동함).

##### print_list 함수
head의 정보를 임시 할당을 받은 노드가 받아서 이어서 처리하는 방법으로 임시 할당 포인터 변수가 NULL을 가리킬 때까지 노드가 가지고 있는 데이터의 정보를 출력함.

#### Dummy Linked List
더미 노드는 맨 앞과 맨 뒤에 노드를 생성하여 자료를 보관하는 모든 노드를 이들 사이에 존재하게 하는 역할을 수행함. 이는 노드를 추가하거나 삭제하는 논리를 단순화할 수 있음. 즉, 함수의 콜이 작아짐.

<p align="center"><img src="https://user-images.githubusercontent.com/45933225/84252839-1a931d80-ab4a-11ea-8fa0-74b1a19180ac.png" width="60%"></p>


다음 이 시간에~~